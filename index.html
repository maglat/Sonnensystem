<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonnensystem</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #020208; overflow: hidden; font-family: system-ui, sans-serif; color: white; }
        
        #loading { position: fixed; inset: 0; background: #020208; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 999; transition: opacity 0.8s; }
        #loading.done { opacity: 0; pointer-events: none; }
        
        .spin { width: 40px; height: 40px; border: 2px solid #223; border-top: 2px solid #00d4ff; border-radius: 50%; animation: rot 0.8s linear infinite; }
        @keyframes rot { to { transform: rotate(360deg); } }
        .loadtxt { margin-top: 15px; color: #445; letter-spacing: 2px; font-size: 0.8rem; }
        
        header { position: fixed; top: 0; left: 0; right: 0; padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); z-index: 100; }
        h1 { font-size: 1.1rem; font-weight: 600; letter-spacing: 2px; color: #bbb; }
        
        .btns { display: flex; gap: 8px; }
        .btn { background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.12); color: #999; padding: 6px 12px; border-radius: 12px; font-size: 0.7rem; cursor: pointer; }
        .btn:hover { background: #00d4ff; color: #000; }
        
        .hint { position: fixed; bottom: 12px; right: 15px; color: #334; font-size: 0.6rem; text-align: right; z-index: 50; }
        
        .infobox { position: fixed; bottom: 20px; left: 20px; background: rgba(8, 12, 22, 0.94); border: 1px solid rgba(100, 150, 200, 0.15); border-radius: 16px; padding: 20px; width: 265px; z-index: 200; animation: slideUp 0.35s ease; }
        @keyframes slideUp{ from{transform:translateY(30px);opacity:0} to{transform:translateY(0);opacity:1} }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="loading">
    <div class="spin"></div>
    <div class="loadtxt">INITIALISIERE...</div>
</div>

<header>
    <h1>Sonnensystem</h1>
    <div class="btns">
        <button class="btn" onclick="camReset()">üîÑ Reset</button>
        <button class="btn" onclick="toggleLbl()">üè∑ Labels</button>
        <button class="btn" onclick="toggleMoons()">üåô Monde</button>
        <button class="btn" onclick="toggleOrbits()">‚óØ Bahnen</button>
        <button class="btn" onclick="cycleSpd()">‚è© <span id="spdDisp">0.2x</span></button>
    </div>
</header>

<div class="hint">Ziehen:Rotieren ¬∑ Scroll:Zoomen ¬∑ Klick:Details</div>

<script>
var DB = {
    sun: {nm:'Sonne', sb:'Unser Stern', ds:'Zentrum des Sonnensystems.', df:'-', dg:'1.39 mio km', ob:'-', mn:'-', cl:0xffff00, emit:0xffaa00, rad:16},
    mercury: {nm:'Merkur', sb:'Klein & Schnell', ds:'Kleinster Planet.', df:'58 mio', dg:'4,879 km', ob:'88 T', mn:'0', cl:0xa0a0a0, inc:7.0},
    venus: {nm:'Venus', sb:'Gl√ºhend Heiss', ds:'Heissester Planet.', df:'108 mio', dg:'12,104 km', ob:'225 T', mn:'0', cl:0xe8c88a, inc:3.4},
    earth: {nm:'Erde', sb:'Blauer Planet', ds:'Unsere Heimat.', df:'150 mio', dg:'12,742 km', ob:'365 T', mn:'1', cl:0x2299ff, atm:0x66aaff, hasClouds:true, hasDetailedAtmos:true, mns:[{r:0.4, d:4, s:12}]},
    mars: {nm:'Mars', sb:'Der Rote', ds:'Der rote Planet.', df:'228 mio', dg:'6,779 km', ob:'687 T', mn:'2', cl:0xdd4422, inc:1.85, mns:[{r:0.25, d:2.5, s:8}, {r:0.2, d:3.5, s:6}]},
    jupiter: {nm:'Jupiter', sb:'Der Riese', ds:'Gr√∂√üter Planet.', df:'778 mio', dg:'139,820 km', ob:'12 J', mn:'95', cl:0xddaa77, inc:1.3, mns:[{r:0.8, d:8, s:4}, {r:0.7, d:10, s:3}, {r:0.9, d:13, s:2}, {r:0.8, d:16, s:1.5}]},
    saturn: {nm:'Saturn', sb:'Mit Ring', ds:'Mit Ringsystem.', df:'1.4 mia', dg:'116,460 km', ob:'29 J', mn:'146', cl:0xeedd99, inc:2.5, rng:true, mns:[{r:0.6, d:9, s:5}, {r:0.4, d:12, s:3}]},
    uranus: {nm:'Uranus', sb:'Geneigt', ds:'Rotiert seitlich.', df:'2.9 mia', dg:'50,724 km', ob:'84 J', mn:'28', cl:0x77ccdd, inc:0.77, mns:[{r:0.4, d:7, s:3}]},
    neptune: {nm:'Neptun', sb:'Windy', ds:'Windigster Planet.', df:'4.5 mia', dg:'49,244 km', ob:'165 J', mn:'16', cl:0x4455cc, inc:1.77, mns:[{r:0.4, d:6, s:4}]}
};

var CFG = [
    {id:'mercury', r:1.8, d:40, s:4.2, t:0.03},
    {id:'venus', r:2.6, d:62, s:1.6, t:3.1},
    {id:'earth', r:2.8, d:86, s:1, t:0.41},
    {id:'mars', r:2, d:118, s:0.53, t:0.44},
    {id:'jupiter', r:7, d:175, s:0.085, t:0.05},
    {id:'saturn', r:6, d:228, s:0.035, t:0.47, rn:true},
    {id:'uranus', r:3.5, d:275, s:0.012, t:1.71},
    {id:'neptune', r:3.3, d:325, s:0.006, t:0.49}
];

var scene, camera, renderer, controls;
var pltObjs = [];
var orbitLines = [];
var lbls = [];
var shwLbl = true;
var showMoons = true;
var showOrbits = true;
var spdMul = 1;
var SPDS = [0.2, 0.5, 1, 2, 5];
var spdIdx = 0;

var sunParticles, sunRays;

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020208);
    scene.fog = new THREE.Fog(0x020208, 500, 3500);
    
    camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 6000);
    camera.position.set(0, 150, 300);
    
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;
    document.body.insertBefore(renderer.domElement, document.body.firstChild);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 30;
    controls.maxDistance = 2000;
    
    var sunLight = new THREE.DirectionalLight(0xfff8e8, 3.0);
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);
    
    var hemiLight = new THREE.HemisphereLight(0x8899bb, 0x222233, 0.8);
    scene.add(hemiLight);
    
    var ambLight = new THREE.AmbientLight(0x333344, 0.5);
    scene.add(ambLight);
    
    var ptLight = new THREE.PointLight(0xffffff, 2, 1000);
    ptLight.position.set(0, 0, 0);
    scene.add(ptLight);
    
    mkStars();
    mkEnhancedSun();
    mkPlanets();
    
    spdMul = SPDS[0];
    
    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onClick);
    
    setTimeout(function(){ document.getElementById('loading').classList.add('done'); }, 600);
    
    animate();
}

// ============ ENHANCED SUN ============
function mkEnhancedSun() {
    var dd = DB.sun;
    
    var vertShader = `
        varying vec3 vNormal;
        varying vec3 vPos;
        void main() {
            vNormal = normalize(normalMatrix * normal);
            vPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;
    
    var fragShader = `
        uniform float time;
        varying vec3 vNormal;
        varying vec3 vPos;
        
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0,i1.z,i2.z,1.0)) + i.y + vec4(0.0,i1.y,i2.y,1.0)) + i.x + vec4(0.0,i1.x,i2.x,1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy,y.xy);
            vec4 b1 = vec4(x.zw,y.zw);
            vec4 s0 = floor(b0)*2.0+1.0;
            vec4 s1 = floor(b1)*2.0+1.0;
            vec4 sh = -step(h,vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
            p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;
            vec4 m = max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
            m=m*m;
            return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
        }
        
        void main() {
            float n1 = snoise(vec3(vPos.x*2.0+vPos.z*0.5, vPos.y*2.0+time*1.2, time*0.4));
            float n2 = snoise(vec3(vPos.x*4.0+time*0.8, vPos.y*4.0, time*1.5));
            
            vec3 cBlack = vec3(0.05, 0.0, 0.0);
            vec3 cRed = vec3(0.9, 0.1, 0.0);
            vec3 cOrange = vec3(1.0, 0.5, 0.0);
            vec3 cYellow = vec3(1.0, 0.85, 0.2);
            vec3 cWhite = vec3(1.0, 1.0, 0.95);
            
            float fire = n1*0.5+n2*0.5+0.5;
            
            vec3 color;
            if(fire < 0.25) color = mix(cBlack, cRed, fire/0.25);
            else if(fire < 0.45) color = mix(cRed, cOrange, (fire-0.25)/0.2);
            else if(fire < 0.65) color = mix(cOrange, cYellow, (fire-0.45)/0.2);
            else color = mix(cYellow, cWhite, (fire-0.65)/0.35);
            
            float fresnel = pow(1.0-abs(dot(vNormal, vec3(0.0,0.0,1.0))), 2.0);
            color = mix(color, cYellow, fresnel*0.4);
            color *= 0.92 + 0.08*sin(time*2.5);
            
            gl_FragColor = vec4(color, 1.0);
        }
    `;
    
    var sunMat = new THREE.ShaderMaterial({
        uniforms: { time: {value: 0} },
        vertexShader: vertShader,
        fragmentShader: fragShader
    });
    
    var sunGeo = new THREE.SphereGeometry(dd.rad, 64, 64);
    var sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sunMesh.userData = {tp:'sun', id:'sun', isSun:true};
    scene.add(sunMesh);
    
    sunMesh.userData.shaderMat = sunMat;
    
    [14, 18, 24, 35].forEach(function(rad, idx) {
        var opacities = [0.12, 0.08, 0.04, 0.015];
        var colors = [0xff6600, 0xff4400, 0xff2200, 0xff1100];
        
        var glow = new THREE.Mesh(
            new THREE.SphereGeometry(rad, 32, 32),
            new THREE.MeshBasicMaterial({
                color: colors[idx],
                transparent: true,
                opacity: opacities[idx],
                side: THREE.BackSide
            })
        );
        scene.add(glow);
    });
    
    pltObjs.push({mesh: sunMesh, cfg: {id:'sun', r:dd.rad, s:0, d:0}});
    
    createSunRays();
    createSunParticles();
}

function createSunRays() {
    var numRays = 50;
    var positions = [];
    var colors = [];
    
    for(var i = 0; i < numRays; i++) {
        var theta = Math.random() * Math.PI * 2;
        var phi = Math.acos(2 * Math.random() - 1);
        
        var r = 16;
        var x1 = r * Math.sin(phi) * Math.cos(theta);
        var y1 = r * Math.sin(phi) * Math.sin(theta);
        var z1 = r * Math.cos(phi);
        
        var len = 10 + Math.random() * 15;
        var x2 = x1 * (1 + len/r);
        var y2 = y1 * (1 + len/r);
        var z2 = z1 * (1 + len/r);
        
        x2 += (Math.random()-0.5) * 4;
        y2 += (Math.random()-0.5) * 4;
        
        positions.push(x1, y1, z1, x2, y2, z2);
        
        var brightness = 0.5 + Math.random() * 0.5;
        colors.push(1, 0.85, brightness, 1);
        colors.push(1, 0.6, 0.2, 0);
    }
    
    var geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));
    
    var mat = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
    });
    
    sunRays = new THREE.LineSegments(geo, mat);
    scene.add(sunRays);
}

function createSunParticles() {
    var count = 120;
    var positions = [];
    
    for(var i = 0; i < count; i++) {
        var theta = Math.random() * Math.PI * 2;
        var phi = Math.acos(2 * Math.random() - 1);
        var r = 17 + Math.random() * 4;
        
        positions.push(
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.sin(phi) * Math.sin(theta),
            r * Math.cos(phi)
        );
    }
    
    var geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    
    var mat = new THREE.PointsMaterial({
        color: 0xffcc66,
        size: 0.6,
        transparent: true,
        opacity: 0.5,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending
    });
    
    sunParticles = new THREE.Points(geo, mat);
    sunParticles.userData.origins = positions.slice();
    sunParticles.userData.phases = [];
    for(var i = 0; i < count; i++) {
        sunParticles.userData.phases.push(Math.random() * Math.PI * 2);
    }
    scene.add(sunParticles);
}

// ============ DETAILED EARTH ATMOSPHERE ============
function createDetailedAtmosphere(group, radius) {
    // Multi-layer Atmosphere
    var layers = [
        {r: radius * 1.08, op: 0.15, col: 0x4499ff},
        {r: radius * 1.12, op: 0.10, col: 0x66bbff},
        {r: radius * 1.17, op: 0.05, col: 0x88ccff},
        {r: radius * 1.27, op: 0.02, col: 0xaaddff}
    ];
    
    layers.forEach(function(l) {
        var mesh = new THREE.Mesh(
            new THREE.SphereGeometry(l.r, 32, 32),
            new THREE.MeshBasicMaterial({
                color: l.col,
                transparent: true,
                opacity: l.op,
                side: THREE.BackSide
            })
        );
        group.add(mesh);
    });
    
    // Custom shader atmosphere glow
    var atmoVS = `
        varying vec3 vNormal;
        void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;
    
    var atmoFS = `
        varying vec3 vNormal;
        
        void main() {
            float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
            vec3 deepBlue = vec3(0.2, 0.4, 0.9);
            vec3 lightBlue = vec3(0.4, 0.7, 1.0);
            vec3 cyan = vec3(0.5, 0.9, 1.0);
            
            vec3 color = mix(deepBlue, lightBlue, intensity);
            color = mix(color, cyan, pow(intensity, 3.0));
            
            float alpha = intensity * 0.5;
            gl_FragColor = vec4(color, alpha);
        }
    `;
    
    var atmoMat = new THREE.ShaderMaterial({
        vertexShader: atmoVS,
        fragmentShader: atmoFS,
        transparent: true,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    var atmoMesh = new THREE.Mesh(
        new THREE.SphereGeometry(radius * 1.33, 32, 32),
        atmoMat
    );
    atmoMesh.userData = {isAtmo: true}; // Mark for animation
    group.add(atmoMesh);
    
    // Clouds
    var cloudGeo = new THREE.SphereGeometry(radius * 1.02, 32, 32);
    var cloudMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.35,
        roughness: 1.0,
        depthWrite: false
    });
    var clouds = new THREE.Mesh(cloudGeo, cloudMat);
    clouds.userData = {isCloud: true}; // Mark for separate rotation
    group.add(clouds);
}

// ============ STANDARD PLANETS ============
function mkStars() {
    var positions = [];
    for(var i = 0; i < 5000; i++) {
        var r = 600 + Math.random() * 1500;
        var theta = Math.random() * Math.PI * 2;
        var phi = Math.acos(2 * Math.random() - 1);
        positions.push(
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.sin(phi) * Math.sin(theta),
            r * Math.cos(phi)
        );
    }
    var geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    var mat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.5,
        sizeAttenuation: true,
        transparent: true,
        opacity: 1.0
    });
    scene.add(new THREE.Points(geo, mat));
}

function mkPlanets() {
    CFG.forEach(function(cf){
        var dd = DB[cf.id];
        var inc = dd.inc || 0;
        
        var orbitGroup = new THREE.Group();
        orbitGroup.rotation.x = inc * Math.PI / 180;
        scene.add(orbitGroup);
        
        var orbitPoints = [];
        for(var op = 0; op <= 96; op++) {
            var oAngle = (op / 96) * Math.PI * 2;
            orbitPoints.push(new THREE.Vector3(Math.cos(oAngle) * cf.d, 0, Math.sin(oAngle) * cf.d));
        }
        var orbitGeo = new THREE.BufferGeometry().setFromPoints(orbitPoints);
        var orbitMat = new THREE.LineBasicMaterial({ color: 0x335566, transparent: true, opacity: 0.35 });
        var orbitLine = new THREE.LineLoop(orbitGeo, orbitMat);
        orbitLine.visible = showOrbits;
        orbitGroup.add(orbitLine);
        orbitLines.push(orbitLine);
        
        var grp = new THREE.Group();
        grp.userData = {tp: 'plt', id: cf.id, ang: Math.random() * Math.PI * 2, spd: cf.s, dst: cf.d, orbitGroup: orbitGroup};
        
        var geo = new THREE.SphereGeometry(cf.r, 36, 36);
        var mat = new THREE.MeshStandardMaterial({
            color: dd.cl, 
            roughness: dd.rs || 0.5, 
            metalness: 0.15
        });
        
        var ms = new THREE.Mesh(geo, mat);
        ms.rotation.z = cf.t;
        ms.castShadow = true;
        ms.receiveShadow = true;
        ms.userData = {id: cf.id};
        grp.add(ms);
        
        // Einfache Atmosph√§re (falls vorhanden und nicht Erde mit Detail-Atmos)
        if(dd.atm && !dd.hasDetailedAtmos) {
            var at = new THREE.Mesh(
                new THREE.SphereGeometry(cf.r * 1.03, 24, 24),
                new THREE.MeshBasicMaterial({color: dd.atm, transparent: true, opacity: 0.2, side: THREE.BackSide})
            );
            ms.add(at);
        }
        
        // DETAILLIERTE ERDE ATMOSPH√ÑRE!
        if(cf.id === 'earth') {
            createDetailedAtmosphere(ms, cf.r);
        }
        
        if(cf.rn || dd.rng) {
            var rg = new THREE.Mesh(
                new THREE.RingGeometry(cf.r * 1.3, cf.r * 2.5, 56),
                new THREE.MeshBasicMaterial({color: 0xccbbaa, side: THREE.DoubleSide, transparent: true, opacity: 0.7})
            );
            rg.rotation.x = Math.PI / 2;
            ms.add(rg);
        }
        
        if(dd.mns && dd.mns.length > 0) {
            var moonGroup = new THREE.Group();
            ms.add(moonGroup);
            dd.mns.forEach(function(mn){
                var mGeo = new THREE.SphereGeometry(mn.r, 16, 16);
                var mMat = new THREE.MeshStandardMaterial({color: 0xbbbb99, roughness: 0.8, metalness: 0.1});
                var mMesh = new THREE.Mesh(mGeo, mMat);
                var mAng = Math.random() * Math.PI * 2;
                mMesh.userData = {tp: 'moon', pid: cf.id, ang: mAng, spd: mn.s, dst: mn.d};
                mMesh.visible = showMoons;
                mMesh.position.set(Math.cos(mAng) * mn.d, 0, Math.sin(mAng) * mn.d);
                moonGroup.add(mMesh);
            });
        }
        
        var cnvs = document.createElement('canvas');
        cnvs.width = 256; cnvs.height = 56;
        var ctx = cnvs.getContext('2d');
        ctx.font = 'bold 22px system-ui';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText(dd.nm, 128, 36);
        ctx.fillText(dd.nm, 128, 36);
        
        var lb = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(cnvs), transparent: true, depthTest: false}));
        lb.scale.set(20, 4.5, 1);
        lb.position.set(0, cf.r + 5, 0);
        lb.visible = shwLbl;
        grp.add(lb);
        lbls.push(lb);
        
        var ag = grp.userData.ang;
        grp.position.set(Math.cos(ag) * cf.d, 0, Math.sin(ag) * cf.d);
        
        orbitGroup.add(grp);
        pltObjs.push({mesh: grp, inner: ms, cfg: cf, isPlanet: true});
    });
}

function onClick(e) {
    var mx = (e.clientX / window.innerWidth) * 2 - 1;
    var my = -(e.clientY / window.innerHeight) * 2 + 1;
    
    var rc = new THREE.Raycaster();
    rc.setFromCamera({x: mx, y: my}, camera);
    
    var clickables = [];
    pltObjs.forEach(function(p){
        if(p.inner) clickables.push(p.inner);
        if(p.mesh) clickables.push(p.mesh);
    });
    
    var hs = rc.intersectObjects(clickables, true);
    
    if(hs.length) {
        var obj = hs[0].object;
        while(obj && !obj.userData.id) obj = obj.parent;
        if(obj && obj.userData.id) shwInf(obj.userData.id);
    }
}

var currInfoId = null;

function shwInf(id) {
    if(currInfoId === id) return;
    currInfoId = id;
    
    var d = DB[id];
    var old = document.querySelector('.infobox');
    if(old) old.remove();
    
    var div = document.createElement('div');
    div.className = 'infobox';
    div.innerHTML = '<button onclick="this.parentElement.remove();currInfoId=null" style="position:absolute;top:8px;right:10px;width:24px;height:24px;border:none;background:rgba(255,255,255,0.1);color:#889;border-radius:50%;cursor:pointer;font-size:1rem;">√ó</button>' +
        '<h2 style="font-size:1.3rem;color:#00d4ff;margin:0 0 2px;">'+d.nm+'</h2>' +
        '<div style="font-size:0.6rem;color:#557;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px;">'+d.sb+'</div>' +
        '<p style="font-size:0.8rem;color:#99a;line-height:1.5;margin:0;">'+d.ds+'</p>' +
        '<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:14px;">' +
        '<div style="background:rgba(255,255,255,0.04);padding:8px;border-radius:8px;"><div style="font-size:0.55rem;color:#567;text-transform:uppercase;">Entfernung</div><div style="font-size:0.8rem;">'+d.df+'</div></div>' +
        '<div style="background:rgba(255,255,255,0.04);padding:8px;border-radius:8px;"><div style="font-size:0.55rem;color:#567;text-transform:uppercase;">√ò</div><div style="font-size:0.8rem;">'+d.dg+'</div></div>' +
        '<div style="background:rgba(255,255,255,0.04);padding:8px;border-radius:8px;"><div style="font-size:0.55rem;color:#567;text-transform:uppercase;">Umlauf</div><div style="font-size:0.8rem;">'+d.ob+'</div></div>' +
        '<div style="background:rgba(255,255,255,0.04);padding:8px;border-radius:8px;"><div style="font-size:0.55rem;color:#567;text-transform:uppercase;">Monde</div><div style="font-size:0.8rem;">'+d.mn+'</div></div>' +
        '</div>' +
        (d.inc !== undefined ? '<div style="margin-top:10px;font-size:0.65rem;color:#556;">Inklation: '+d.inc+'¬∞</div>' : '');
    document.body.appendChild(div);
}

window.camReset = function() { camera.position.set(0, 150, 300); controls.target.set(0, 0, 0); };
window.toggleLbl = function() { shwLbl = !shwLbl; lbls.forEach(function(l){ l.visible = shwLbl; }); };
window.toggleMoons = function() {
    showMoons = !showMoons;
    pltObjs.forEach(function(p){
        if(p.isPlanet && p.inner) {
            p.inner.children.forEach(function(ch){
                if(ch.isGroup) ch.children.forEach(function(m){ m.visible = showMoons; });
            });
        }
    });
};
window.toggleOrbits = function() { showOrbits = !showOrbits; orbitLines.forEach(function(line){ line.visible = showOrbits; }); };
window.cycleSpd = function() { spdIdx = (spdIdx + 1) % SPDS.length; spdMul = SPDS[spdIdx]; document.getElementById('spdDisp').textContent = spdMul + 'x'; };

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

var lastT = 0;
function animate(t) {
    requestAnimationFrame(animate);
    var dt = (t - lastT) / 1000 || 0.016;
    lastT = t;
    if(dt > 0.1) return;
    
    var timeSec = t * 0.001;
    
    // Sun shader update
    pltObjs.forEach(function(p) {
        if(p.cfg.s === 0 && p.mesh.userData.isSun && p.mesh.userData.shaderMat) {
            p.mesh.userData.shaderMat.uniforms.time.value = timeSec;
        }
    });
    
    // Sun rays
    if(sunRays) sunRays.rotation.y = timeSec * 0.03;
    
    // Sun particles
    if(sunParticles) {
        var pos = sunParticles.geometry.attributes.position;
        var orig = sunParticles.userData.origins;
        var phase = sunParticles.userData.phases;
        
        for(var i = 0; i < pos.count; i++) {
            var i3 = i * 3;
            var drift = (Math.sin(timeSec * 0.4 + phase[i]) * 0.5 + 0.5) * 2.5;
            var ox = orig[i3];
            var oy = orig[i3+1];
            var oz = orig[i3+2];
            var dist = Math.sqrt(ox*ox + oy*oy + oz*oz);
            pos.array[i3] = ox + (ox/dist) * drift;
            pos.array[i3+1] = oy + (oy/dist) * drift;
            pos.array[i3+2] = oz + (oz/dist) * drift;
        }
        pos.needsUpdate = true;
    }
    
    // Planets
    pltObjs.forEach(function(p){
        if(p.cfg.s === 0) return;
        
        var u = p.mesh.userData;
        u.ang += dt * p.cfg.s * 0.35 * spdMul;
        p.mesh.position.set(Math.cos(u.ang) * u.dst, 0, Math.sin(u.ang) * u.dst);
        
        if(p.inner) p.inner.rotation.y += dt * 1.5 * spdMul;
        
        // Clouds and atmosphere rotation for Earth
        if(p.cfg.id === 'earth' && p.inner) {
            p.inner.children.forEach(function(child) {
                if(child.userData && child.userData.isCloud) {
                    child.rotation.y += dt * 0.3 * spdMul; // Faster than earth!
                }
            });
        }
        
        // Moon animation
        if(p.inner) {
            p.inner.children.forEach(function(child){
                if(child.isGroup) {
                    child.children.forEach(function(moon){
                        if(moon.userData.tp === 'moon') {
                            moon.userData.ang += dt * moon.userData.spd * 2 * spdMul;
                            var ma = moon.userData.ang;
                            var md = moon.userData.dst;
                            moon.position.set(Math.cos(ma) * md, 0, Math.sin(ma) * md);
                        }
                    });
                }
            });
        }
    });
    
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>